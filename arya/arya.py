#!/usr/bin/env python
'''
APIC Rest Python Adapter (arya)

Paul Lesiak - palesiak@cisco.com

Copyright (C) 2014 Cisco Systems Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Converts blocks of APIC XML/JSON into the equivalent cobra code to construct
the objects.
'''

import os
import sys
import xml.etree.ElementTree as ETree
import json
import keyword
import StringIO
from argparse import ArgumentParser
from string import Template
from collections import OrderedDict


class arya:

    # attributes that should be excluded from autogenerated code, even if they
    # are provided
    EXCLUDEATTR = ['configIssues', 'stateQual', 'replTs', 'modTs', 'lcC',
                   'childAction',  'monPolDn',  'state',  'lcOwn', 'rn',
                   'triggerSt',    'configSt',  'scope',  'uid',   'dn']

    # Sort the list of APIC package names by reverse length so we can do a
    # longest prefix match on the moname
    # If the object model has changed considerable you may need to update this list
    # import os, cobra.model;
    # l = [k.split('.')[0] for k in \
    # os.listdir(os.path.normpath(cobra.model.__path__[0])) if k.endswith(
    # '.py') and not k.startswith('_')]
    # print l
    APICPACKAGES = sorted(
        ['testinfralab', 'policer', 'rtpfx', 'task', 'file', 'hvs',
         'eqptcapacity', 'monitor', 'rtmap', 'span', 'eqpt', 'geo',
         'traceroutep',  'lldptlv', 'rtflt', 'snmp', 'draw', 'fsm',
         'traceroute',   'isistlv', 'rtcom', 'satm', 'dhcp', 'epm',
         'lldptlvpol',   'eqptcap', 'pcons', 'rule', 'copp', 'dns',
         'imginstall',   'dhcptlv', 'mcast', 'rmon', 'coop', 'dbg',
         'dhcptlvpol',   'uribv4',  'maint', 'repl', 'comp', 'ctx',
         'synthetic',    'tunnel',  'leqpt', 'reln', 'comm', 'cnw',
         'statstore',    'sysmgr',  'l3ext', 'rbqm', 'vpc',  'cdp',
         'igmpsnoop',    'syslog',  'l3cap', 'qosp', 'vns',  'cap',
         'eqptdiagp',    'rtleak',  'l2ext', 'qosm', 'vmm',  'bgp',
         'condition',    'rtctrl',  'l2cap', 'proc', 'top',  'arp',
         'topoctrl',     'opflex',  'l1cap', 'pres', 'tlv',  'aib',
         'sysdebug',     'naming',  'infra', 'pool', 'tag',  'aaa',
         'rtregcom',     'memory',  'ident', 'ping', 'svi',  'vz',
         'rtextcom',     'icmpv6',  'glean', 'phys', 'sts',  'pc',
         'observer',     'icmpv4',  'fault', 'ospf', 'stp',  'os',
         'firmware',     'health',  'extnw', 'mock', 'rpm',  'nw',
         'eqptdiag',     'fvtopo',  'event', 'mgmt', 'rib',  'nd',
         'datetime',     'fmcast',  'ethpm', 'lldp', 'res',  'mo',
         'callhome',     'fabric',  'dbgac', 'lacp', 'qos',  'l3',
         'actrlcap',     'dbgexp',  'ctrlr', 'l3vm', 'psu',  'l2',
         'vlanmgr',      'config',  'adcom', 'isis', 'pol',  'l1',
         'sysmgrp',      'compat',  'actrl', 'ipv6', 'pki',  'ip',
         'syshist',      'action',  'vsvc',  'ipv4', 'oam',  'im',
         'sysfile',      'vxlan',   'vlan',  'igmp', 'mon',  'ha',
         'svccore',      'stats',   'trig',  'icmp', 'mcp',  'fv',
         'regress',      'rtsum',   'test',  'fvns', 'lbp',  'ac'],
        key=lambda l: 100 * 1 / len(l))

    def __init__(self):
        """
        Class constructor
        Define some of the python modules we will always be importing
        """
        self.objectcounter = 0
        self.importlist = [
            'cobra.mit.access', 'cobra.mit.session', 'cobra.mit.request']
        self.varnames = OrderedDict()

    def resolvemoname(self, moname):
        """
        This method does a longest prefix match on the name of an mo, e.g.,
        fvTenant and then finds the APIC package name that this class belongs
        to. If it's unable to find a matching package name, it means something
        in the input XML/JSON is screwy and that we should raise an exception
        returns: packageName, className, e.g., fv, Tenant
        """
        for c in self.APICPACKAGES:
            if moname.startswith(c):
                package = c
                name = moname[len(c):len(moname)]
                break
        else:
            raise LookupError(
                'Unable to find class %s in package list' % moname)
        return package, name

    def getvarname(self, objname):
        """
        This method helps track variable names that are in use so in case of
        nested and/or duplicate variable names the code has to auto generate
        we can easily differentiate between them. it's simply an occurence
        counter, that returns the name of the object with its occurence count
        appended to the end
        """
        if objname in self.varnames:
            self.varnames[objname] += 1
            return '%s%d' % (objname, self.varnames[objname])
        else:
            self.varnames[objname] = 1
            return '{0}'.format(objname)

    def buildattributestring(self, attr):
        """
        Builds the attribute string for the object creation

        attr is a dict containing name value pairs of the attribute and value
        """
        if not isinstance(attr, dict):
            attr = dict()

        parmlist = []
        for k, v in attr.items():
            if k not in self.EXCLUDEATTR:
                # if the name is status and value is not deleted, skip that
                # otherwise, include it
                if k == 'status' and v != 'deleted':
                    pass
                else:
                    # any properly formed xml/json should have keywords already
                    # escaped however this is just a sanity check. also, it
                    # misses 'to' which is not a keyword in python, but is
                    # treated as such in pymeta oh well
                    if keyword.iskeyword(k):
                        k += '_'

                    parmlist.append('%s=\'%s\'' % (k, v))

        attribstr = ', '.join(parmlist)

        return attribstr

    def buildcommand(self, mofullname, moparent, attr):
        """
        This is the build ol' chunk of code that accepts the mo, it's parent
        and attributes and then creates the equivalent cobra calls
        This method should be pretty meta format agnostic -- I was able to use
        this same method for both JSON and XML with no changes

        mofullname - complete MO name, extracted from the JSON key/XML tag name
        moparent - parent object variable name
        attr - dict (key/value pair) containing attributes for this MO
        """

        cmd = ''

        mopackagename, moclassname = self.resolvemoname(mofullname)

        attribstr = self.buildattributestring(attr)

        cobrapackagename = 'cobra.model.%s' % mopackagename
        if cobrapackagename not in self.importlist:
            self.importlist.append(cobrapackagename)

        objectvarname = self.getvarname(mofullname)
        if mofullname == 'polUni':
            return '', moparent

        parms = [moparent]
        if attribstr != '':
            parms.append(attribstr)

        cmd += '%s = cobra.model.%s.%s(%s)\n' % (
            objectvarname, mopackagename, moclassname, ', '.join(parms))

        self.objectcounter += 1
        return cmd, objectvarname

    def recursexmltree(self, elem, parentname):
        pycode, objectname = self.buildcommand(
            elem.tag, parentname, elem.attrib)
        for e in elem:
            pycode += self.recursexmltree(e, objectname)

        return pycode

    def recursejsondict(self, jsondict, parentname):
        pycode, objectname = self.buildcommand(
            jsondict.keys()[0], parentname,
            jsondict[jsondict.keys()[0]].get('attributes', {}))

        if 'children' in jsondict[jsondict.keys()[0]]:
            for j in jsondict[jsondict.keys()[0]]['children']:
                pycode += self.recursejsondict(j, objectname)

        return pycode

    def getpython(self, xmlstr=None, jsonstr=None, apicip='1.1.1.1',
                  apicpassword='password', apicuser='admin'):

        pycodetemplate = Template("""#!/usr/bin/env python
'''
Autogenerated code using $myFileName
Original Object Document Input: 
$sourceDoc
'''

raise RuntimeError('Please review the auto generated code before ' +
                   'executing the output. Some placeholders will ' +
                   'need to be changed')
# list of packages that should be imported for this code to work
$imports
from cobra.internal.codec.xmlcodec import toXMLStr

# log into an APIC and create a directory object
ep = cobra.mit.access.EndPoint('$apicHost', secure=False, port=80)
ls = cobra.mit.session.LoginSession('$apicUser', '$apicPassword')
md = cobra.mit.access.MoDirectory(ep, ls)
md.login()

# lookup the top level object on which operations will be made
$lookupCode

# build the request using cobra syntax
$objStructureCode

# commit the generated code to APIC
print toXMLStr($topMo)
$commitCode""")

        vals = {}
        topobjectvar = 'topMo'

        if xmlstr and jsonstr:
            raise ValueError('Both xmlfile and jsonfile provided. Which one ' +
                             'do I listen to? I am so confused!')

        toptag = None
        if xmlstr:
            tree = ETree.ElementTree(ETree.fromstring(xmlstr))
            root = tree.getroot()
            toptag = root.tag
            vals['objStructureCode'] = self.recursexmltree(root, topobjectvar)

        if jsonstr:
            j = json.loads(jsonstr)
            toptag = j.keys()[0]
            vals['objStructureCode'] = self.recursejsondict(j, topobjectvar)

        toptaghelper = {
            'polUni': {'dn': 'uni', 'varnameindex': 1},
            'infraInfra': {'dn': 'uni', 'varnameindex': 0},
            'fvTenant': {'dn': 'uni', 'varnameindex': 0}
        }

        if toptag in toptaghelper:
            vals['lookupCode'] = '%s = md.lookupByDn(\'%s\')' % (
                topobjectvar, toptaghelper[toptag]['dn'])
            varnameindex = toptaghelper[toptag]['varnameindex']
        else:
            varnameindex = 0
            lookupcodestr = '# type in your dn/class query for the top '
            lookupcodestr += 'object here\n'
            lookupcodestr += '{0} = md.lookupByDn(\'...\')'.format(topobjectvar)
            vals['lookupCode'] = lookupcodestr

        vals['apicHost'] = apicip
        vals['apicUser'] = apicuser
        vals['apicPassword'] = apicpassword
        vals['sourceDoc'] = xmlstr or jsonstr
        vals['myFileName'] = str(__file__)
        vals['imports'] = '\n'.join(['import %s' % i for i in self.importlist])
        vals['topMo'] = topobjectvar
        commitcodestr = 'c = cobra.mit.request.ConfigRequest()\n'
        commitcodestr += 'c.addMo('
        commitcodestr += '{0})\n'.format(self.varnames.keys()[varnameindex])
        commitcodestr += 'md.commit(c)\n'
        vals['commitCode'] = commitcodestr
        return pycodetemplate.substitute(vals)


def isxmlorjson(s):
    try:
        json.loads(s)
        isjson = True
    except ValueError:
        isjson = False

    try:
        ETree.ElementTree(ETree.fromstring(s))
        isxml = True
    except ETree.ParseError:
        isxml = False

    if isjson and isxml:
        raise ValueError('This file appears to be both XML and JSON. I am ' +
                         'confused. Goodbye')

    if isjson:
        return 'json'
    elif isxml:
        return 'xml'
    else:
        return None


def main():
    parser = ArgumentParser('Code generator for APIC cobra SDK')
    parser.add_argument(
        '-f', '--file', help='Document containing post to be sent to ' +
                             'REST API', required=False)
    parser.add_argument(
        '-s', '--stdin', help='Parse input from stdin, for use as a filter, ' +
                              'e.g., cat doc.xml | {0} -s'.format(__file__),
        action='store_true', default=False, required=False)
    parser.add_argument(
        '-d', '--sourcedir', help='Specify a source directory containing ' +
                                  'ACI object files you want to convert to python. ',
        required=False)
    parser.add_argument(
        '-t', '--targetdir', help='Where to write the .py files that come ' +
                                  'from the -d directory. If none is ' +
                                  'specified, it will default to SOURCEDIR',
        required=False)
    parser.add_argument(
        '-i', '--ip', help='IP address of APIC', required=False,
        default='1.1.1.1')
    parser.add_argument(
        '-p', '--password', help='Password for admin account on APIC',
        required=False, default='password')
    args = parser.parse_args()

    if not args.file and not args.sourcedir and not args.stdin:
        print('ERROR: You must specify at least -x, -j, -i or -d')
        print('')
        parser.print_help()
        sys.exit(1)

    def processinputstr(inputstr, args):
        format = isxmlorjson(inputstr)

        if format == 'xml':
            return arya().getpython(xmlstr=inputstr, apicip=args.ip,
                                        apicpassword=args.password)
        elif format == 'json':
            return arya().getpython(jsonstr=inputstr, apicip=args.ip,
                                        apicpassword=args.password)
        else:
            raise IOError('Unsupported format passed as input. Please check ' +
                          'that input is formatted correctly in JSON or XML syntax')

    if args.file or args.stdin:
        if args.stdin:
            inputstr = sys.stdin.read()
        elif args.file:
            with file(args.file, 'r') as inputfilehandle:
                inputstr = inputfilehandle.read()
        print processinputstr(inputstr, args)
        sys.exit(0)

    if args.sourcedir:
        sourcedir = os.path.realpath(args.sourcedir)
        if args.targetdir:
            targetdir = os.path.realpath(args.targetdir)
        else:
            targetdir = sourcedir

        print 'Reading from %s and writing to %s' % (sourcedir, targetdir)
        os.chdir(args.sourcedir)
        for files in os.listdir('.'):
            if (files.lower().endswith('.xml') or
                    files.lower().endswith('.json')):
                outfilename = os.path.join(
                    targetdir, os.path.basename(files).split('.')[-2] + '.py')
                if os.path.isfile(outfilename):
                    raise IOError(
                        'Output file: %s already exists' % outfilename)
                print '%s -> %s' % (files, outfilename)

                p = None
                try:
                    with file(files, 'r') as f:
                        p = processinputstr(f.read(), args)
                except ETree.ParseError:
                    print 'XML parser error %s' % files
                else:
                    with open(outfilename, 'w') as f:
                        f.write(p)

if __name__ == '__main__':
    main()
